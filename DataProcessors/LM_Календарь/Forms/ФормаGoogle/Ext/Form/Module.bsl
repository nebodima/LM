//В обработке использовалось
//Функция транслитерации http://infostart.ru/public/94760/
//Преобразование 1С->JSON->1С http://infostart.ru/public/308198/

&НаКлиенте
Процедура АвторизацияGoogle(Команда)
	
	ФормаАвторизации = ПолучитьФорму("Обработка.LM_Календарь.Форма.ФормаАвторизации");
	ФормаАвторизации.Заголовок = "Авторизация Google";
	ФормаАвторизации.ДокументHTML = "https://accounts.google.com/o/oauth2/auth?redirect_uri=urn:ietf:wg:oauth:2.0:oob&response_type=code&client_id=953010898663-nfthn853j7r5vg43r5g2tgttnvj6ocng.apps.googleusercontent.com&scope=https://www.googleapis.com/auth/calendar";
	Результат = ФормаАвторизации.ОткрытьМодально();
	
	Если ЗначениеЗаполнено(Гугл_access_token) Тогда
		Гугл_SuccessСode = Результат;
		События.Очистить();
		ТипыОповещенияСобытия.Очистить();
		ПолучениеТокена();
		ПолучитьКалендариНаСервере();
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Функция ОткрытьВзаиморасчетыНаСервере()
	
	ПараметрыОткрытия = Новый Структура(); 
	ПараметрыОткрытия.Вставить("СформироватьПриОткрытии", Истина); 
	
	Возврат ПараметрыОткрытия;
	
КонецФункции


&НаСервере
Процедура ПолучениеТокена(ПовторныйТокен = Ложь)
	
	Boundary = СтрЗаменить(Строка(Новый УникальныйИдентификатор()), "-", "");		
	МассивФайлов = Новый Массив; 	
	Попытка    		
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла("txt");
		ПостФайл = Новый ЗаписьТекста(ИмяВременногоФайла, КодировкаТекста.ANSI, Символы.ПС, Ложь);
		
		ПостФайл.ЗаписатьСтроку("--" + Boundary);
		ПостФайл.ЗаписатьСтроку("Content-disposition: form-data; name=""code""" + Символы.ПС);
		ПостФайл.ЗаписатьСтроку(?(ПовторныйТокен, Гугл_refresh_token, Гугл_SuccessСode));
		ПостФайл.ЗаписатьСтроку("--" + Boundary);
		
		ПостФайл.ЗаписатьСтроку("--" + Boundary);
		ПостФайл.ЗаписатьСтроку("Content-disposition: form-data; name=""client_id""" + Символы.ПС);
		ПостФайл.ЗаписатьСтроку(ГуглКлиентИд);
		ПостФайл.ЗаписатьСтроку("--" + Boundary);
		
		ПостФайл.ЗаписатьСтроку("--" + Boundary);
		ПостФайл.ЗаписатьСтроку("Content-disposition: form-data; name=""client_secret""" + Символы.ПС);
		ПостФайл.ЗаписатьСтроку(Гугл_client_secret);
		ПостФайл.ЗаписатьСтроку("--" + Boundary);
		
		ПостФайл.ЗаписатьСтроку("--" + Boundary);
		ПостФайл.ЗаписатьСтроку("Content-disposition: form-data; name=""redirect_uri""" + Символы.ПС);
		ПостФайл.ЗаписатьСтроку(ГуглРедиректУРЛ);
		ПостФайл.ЗаписатьСтроку("--" + Boundary);
		
		ПостФайл.ЗаписатьСтроку("--" + Boundary);
		ПостФайл.ЗаписатьСтроку("Content-disposition: form-data; name=""grant_type""" + Символы.ПС);
		ПостФайл.ЗаписатьСтроку("authorization_code");		
		ПостФайл.ЗаписатьСтроку("--" + Boundary + "--");
		
		ПостФайл.Закрыть();	
		
		МассивФайлов.Добавить(ИмяВременногоФайла);		
		ИмяФайлаОтправки = КаталогВременныхФайлов() + Boundary + ".txt";
		ОбъединитьФайлы(МассивФайлов, ИмяФайлаОтправки);  		
	Исключение
		Сообщить("Не удалось сохранить файл отправки: " + ОписаниеОшибки());
		Возврат;
	КонецПопытки; 
	
	
	Заголовоки = Новый Соответствие(); 
	Заголовоки.Вставить("Content-Type", "multipart/form-data; boundary=" + Boundary);
	
	ФайлОтправки = Новый Файл(ИмяВременногоФайла);
	Заголовоки.Вставить("Content-Length", XMLСтрока(ФайлОтправки.Размер()));
	
	Соединение = Новый HTTPСоединение("accounts.google.com",,,,,Истина);
	
	Попытка
		ЗапросHTTP = Новый HTTPЗапрос("/o/oauth2/token", Заголовоки);
		ЗапросHTTP.УстановитьИмяФайлаТела(ИмяВременногоФайла); //Устанавливает имя файла, из которого будет прочитано тело POST-запроса.
		
		ОтветHTTP = Соединение.ОтправитьДляОбработки(ЗапросHTTP);
	Исключение
		Сообщить("Неудачная попытка соединения с accounts.google.com: " + ОписаниеОшибки());
		Возврат;
	КонецПопытки;
	Ответ = ОтветHTTP.ПолучитьТелоКакСтроку();
	Соединение = Неопределено;
	ЗапросHTTP = Неопределено;
	УдалитьФайлы(ИмяВременногоФайла);
	Для каждого ЭлементМассива Из МассивФайлов Цикл
		УдалитьФайлы(ЭлементМассива);
	КонецЦикла;
	Получить_access_token(Ответ);
КонецПроцедуры

&НаСервере
Процедура Получить_access_token(ТекстJSON)
	Попытка
		Результат = ЗаполнитьСтруктуруИзОтветаJSON(ТекстJSON);
		//Результат = UnJSON(ТекстJSON);
	Исключение
		Сообщить("Не удалось преобразовать строку в значение! " + ОписаниеОшибки());
		Возврат;
	КонецПопытки;
	Если ТипЗнч(Результат) = Тип("Структура") И Результат.Свойство("access_token") Тогда
		Гугл_access_token = Результат.access_token; 
		Гугл_refresh_token = Результат.refresh_token;//Используется для повторного получения токена, гогда закончился срок действия access_token
	КонецЕсли; 
КонецПроцедуры // Получить_access_token()

&НаСервере
Функция СтрокуВЗначениеНаСервере(ТекстJSON)
	Попытка
		Результат = ЗаполнитьСтруктуруИзОтветаJSON(ТекстJSON);
		//Результат = UnJSON(ТекстJSON);
	Исключение
		Сообщить("Не удалось преобразовать строку в значение! " + ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;
	Если ТипЗнч(Результат) = Тип("Структура") И Не Результат.Свойство("error")Тогда
		Календари.Очистить();
		Для каждого Строка Из Результат.items Цикл
			НоваяСтрока = Календари.Добавить();
			НоваяСтрока.Наименование = Строка.summary;
			НоваяСтрока.ИД = Строка.id;  	
			Если Строка.accessRole = "reader" Тогда
				НоваяСтрока.ТолькоПросмотр = Истина;		
			КонецЕсли; 
		КонецЦикла;
	ИначеЕсли Результат.Свойство("error")Тогда 
		Ошибки = ТекстJSON;
		Сообщить("Нужно заново авторизоваться в Google!");
		ПолучениеТокена(Истина);
	КонецЕсли; 
	Возврат "";
КонецФункции

&НаКлиенте
Процедура ПолучитьКалендари(Команда) 
	ПолучитьКалендариНаСервере();
КонецПроцедуры 

&НаСервере
Процедура ПолучитьКалендариНаСервере()
	
	Соединение = Новый HTTPСоединение("www.googleapis.com",,,,,Истина);
	ЗапросHTTP = Новый HTTPЗапрос("/calendar/v3/users/me/calendarList?access_token=" + Гугл_access_token);
	ОтветHTTP = Соединение.Получить(ЗапросHTTP);
	Ответ = ОтветHTTP.ПолучитьТелоКакСтроку();
	Результат = СтрокуВЗначениеНаСервере(Ответ);
	Соединение = Неопределено;
	ЗапросHTTP = Неопределено;

КонецПроцедуры

&НаКлиенте
Процедура ПолучитьСобытия(Команда)
	ТекущиеДанные = Элементы.Календари.ТекущиеДанные;
	ИдКалендаря = КодироватьСтрокуНаСервере(ТекущиеДанные.ИД, "КодировкаURL");
	Если Не ТекущиеДанные = Неопределено Тогда
		//=============================================================
		//Удаляем события календаря из табличной части
		//и типы оповещения событий по указанному календарю
		Сч = 0;
		Пока Не Сч = События.Количество() Цикл
			Если События[Сч].Календарь = ТекущиеДанные.Наименование Тогда
				ИдСобытия = События[Сч].ИД;
				НайденыеСтроки = ТипыОповещенияСобытия.НайтиСтроки(Новый Структура("Событие", ИдСобытия));
				Для каждого Строка Из НайденыеСтроки Цикл
					ТипыОповещенияСобытия.Удалить(ТипыОповещенияСобытия.Индекс(Строка));			
				КонецЦикла; 				
				События.Удалить(Сч);
			Иначе	
				Сч = Сч + 1;
			КонецЕсли; 	
		КонецЦикла; 
		//==============================================================
		Соединение = Новый HTTPСоединение("www.googleapis.com",,,,,Истина);
		ЗапросHTTP = Новый HTTPЗапрос("/calendar/v3/calendars/" + ИдКалендаря + "/events?access_token=" + Гугл_access_token);
		ОтветHTTP = Соединение.Получить(ЗапросHTTP);
		Ответ = ОтветHTTP.ПолучитьТелоКакСтроку();
		ПолучитьСобытияИзОтвета(Ответ);
		Соединение = Неопределено;
		ЗапросHTTP = Неопределено;
		Если Элементы.События.ТекущиеДанные = Неопределено Тогда 
			СобытияПриАктивизацииСтроки(Команда);
		КонецЕсли; 
	КонецЕсли; 
	ПодключитьОбработчикОжидания("ИзменитьЦветПоля", 5, Истина);
КонецПроцедуры

&НаКлиенте
Процедура ИзменитьЦветПоля()
	Изменено = Ложь;
	Для каждого Строка Из События Цикл
		Если Строка.Новое = 1 Тогда
			Строка.Новое = 2;
			Изменено = Истина;
		ИначеЕсли Строка.Новое = 2 Тогда	
			Строка.Новое = 3;
			Изменено = Истина;
		ИначеЕсли Строка.Новое = 3 Тогда	
			Строка.Новое = 0;
		КонецЕсли; 		
	КонецЦикла;  
	Если Изменено Тогда
		ПодключитьОбработчикОжидания("ИзменитьЦветПоля", 5, Истина); 
	КонецЕсли; 	
КонецПроцедуры // ИзменитьЦветПоля()

&НаСервере
Функция КодироватьСтрокуНаСервере(Знач Строка, СпособКодирования)
	
	Возврат КодироватьСтроку(Строка,СпособКодированияСтроки[СпособКодирования]);	
	
КонецФункции // ()

&НаСервере
Процедура ПолучитьСобытияИзОтвета(ТекстJSON, НаименованиеКалендаря = "")
	
	Попытка
		Результат = ЗаполнитьСтруктуруИзОтветаJSON(ТекстJSON);
		//Результат = UnJSON(ТекстJSON);
	Исключение
		Сообщить("Не удалось преобразовать строку в значение! " + ОписаниеОшибки());
		Возврат;
	КонецПопытки;
	Если ТипЗнч(Результат) = Тип("Структура") И Не Результат.Свойство("error") Тогда
		Если Результат.Свойство("items") Тогда
			Для каждого Строка Из Результат.items Цикл
				ДобавитьСобытиеВТаблицу(Строка, Результат.summary);
			КонецЦикла;
		ИначеЕсли Результат.Свойство("created") Тогда	
			ДобавитьСобытиеВТаблицу(Результат, НаименованиеКалендаря);			
		КонецЕсли; 
	ИначеЕсли Результат.Свойство("error")Тогда 
		Ошибки = ТекстJSON;
		Сообщить("Нужно заново авторизоваться в Google!");
		//ПолучениеТокена(Истина);
		
		Попытка
			Сообщить(Результат.error.message);
		Исключение
		КонецПопытки;
	КонецЕсли; 	
	
	События.Сортировать("ДатаНачала, Наименование");
	ТипыОповещенияСобытия.Сортировать("День, Время");
	
КонецПроцедуры // ПолучитьСобытия()

&НаСервере
Процедура ДобавитьСобытиеВТаблицу(Строка, Календарь)
	
	Если Строка.status = "cancelled" Тогда
		Возврат;		
	КонецЕсли;
	
	НоваяСтрока = События.Добавить();
	НоваяСтрока.Календарь 		= Календарь;
	НоваяСтрока.Наименование 	= Строка.summary;
	НоваяСтрока.ИД 				= Строка.id; 
	
	Если Строка.start.Свойство("dateTime") Тогда
		ДатаНачала = СтрЗаменить(Строка.start.dateTime,"-","");
		ДатаНачала = Лев(СтрЗаменить(ДатаНачала,"T",""),16);
		ДатаНачала = Дата(СтрЗаменить(ДатаНачала,":","")); 
	Иначе	//2014-07-03T10:00:00+04:00
		ДатаНачала = Неопределено;
	КонецЕсли;
	
	Если Строка.end.Свойство("dateTime") Тогда
		ДатаОкончания = СтрЗаменить(Строка.end.dateTime,"-","");
		ДатаОкончания = Лев(СтрЗаменить(ДатаОкончания,"T",""),16);
		ДатаОкончания = Дата(СтрЗаменить(ДатаОкончания,":",""));
	Иначе	
		ДатаОкончания = Неопределено;
	КонецЕсли; 
	
	НоваяСтрока.ДатаНачала 		= ДатаНачала;
	НоваяСтрока.ДатаОкончания 	= ДатаОкончания;
	НоваяСтрока.htmlLink 		= Строка.htmlLink;
	//DEDa
	НоваяСтрока.iCalUID 		= Строка.iCalUID;//Путь к мероприятию  9hr28mkpblrnautlcv2ug2t2es@google.com
	НоваяСтрока.Новое 			= 1;
	НоваяСтрока.ВесьДень 		= (НоваяСтрока.ДатаОкончания - НоваяСтрока.ДатаНачала) = 86400;
	
	Попытка  	
		Для каждого СтрокаОповещение Из Строка.reminders.overrides Цикл
			НС = ТипыОповещенияСобытия.Добавить();
			НС.Событие 	= Строка.id;
			НС.method 	= СтрокаОповещение.method;
			НС.minutes 	= СтрокаОповещение.minutes;
			НС.День 	= Цел(НС.minutes / 1440) + 1;
			НС.Время 	= '00020101' - НС.minutes * 60;
		КонецЦикла;   	
	Исключение	
	КонецПопытки; 
	
КонецПроцедуры // ДобавитьСобытиеВТаблицу()

&НаСервере
Процедура СоздатьНапоминанияДняРожденияНаСервере(Знач ИдКалендаря, Знач НаименованиеКалендаря)
	
	СписокНапоминаний = СформироватьСписокУроков();
	
	Для Каждого Напомининие из СписокНапоминаний Цикл
		
		Boundary = СтрЗаменить(Строка(Новый УникальныйИдентификатор()), "-", ""); 		
		МассивФайлов = Новый Массив;
		
		Попытка 		
			ИмяВременногоФайла = ПолучитьИмяВременногоФайла("txt");
			ФайлJSON = Новый ЗаписьТекста(ИмяВременногоФайла, КодировкаТекста.ANSI, Символы.ПС, Ложь);
			
			ДатаНачала 		= Формат(Напомининие.Ссылка.Дата, "ДФ=гггг-") + Формат(Напомининие.Ссылка.Дата,"ДФ=MM") + "-" + Формат(Напомининие.Ссылка.Дата,"ДФ=dd") +"T"+Формат(Напомининие.Ссылка.Дата,"ДЛФ=T")+"+00:00";
			ДатаНачалаВ1С 	= ДатаНачала;
			ДатаОкончания 	= Напомининие.Ссылка.Дата-('00010101'-Напомининие.Ссылка.КоличествоЧасов);
			ДатаОкончания 	= Формат(Напомининие.Ссылка.Дата, "ДФ=гггг-") + Формат(ДатаОкончания, "ДФ=ММ-") + Формат(ДатаОкончания, "ДФ=дд")+"T"+Формат(ДатаОкончания,"ДЛФ=T")+"+00:00";  
			
			Текст = Новый Структура;
			Текст.Вставить("start", Новый Структура);
			Текст.start.Вставить("dateTime", ДатаНачала);
			Текст.start.Вставить("timeZone", timeZone);
			Текст.Вставить("end", Новый Структура);
			Текст.end.Вставить("dateTime", ДатаОкончания);
			Текст.end.Вставить("timeZone", timeZone);
			
			
			НаименованиеСобытия = Строка(Напомининие.Ссылка.Педагог);
			СписокУчеников = "";
			Для Каждого СтрУч из Напомининие.Ссылка.Ученики Цикл
				   СписокУчеников = СписокУчеников + Строка(СтрУч.Ученик)+"; ";
			КонецЦикла;			
			Текст.Вставить("description", Транслит(СписокУчеников)); //Текст
			Текст.Вставить("summary", Транслит(Строка(Напомининие.Ссылка.ПредметОбучения))); //Транслит(НаименованиеСобытия)
			Текст.Вставить("recurrence", Новый Массив);  			
			Текст.Вставить("reminders", Новый Структура);
			
			//Текст.reminders.Вставить("useDefault", ?(ИспользоватьНастройкиОповещенияПоУмолчанию Или ТипыОповещения.Количество() = 0, "true", "false"));
			//Если Не ИспользоватьНастройкиОповещенияПоУмолчанию И Не ТипыОповещения.Количество() = 0 Тогда
			//	Текст.reminders.Вставить("overrides", Новый Массив);
			//	Для каждого Метод Из ТипыОповещения Цикл
			//		Если ЗначениеЗаполнено(Метод.method) И ЗначениеЗаполнено(Метод.minutes) Тогда
			//			Оповещение = Новый Структура;
			//			Оповещение.Вставить("method", Метод.method);
			//			Оповещение.Вставить("minutes", Метод.minutes + ?(Метод.День = 1, 0, (Метод.День - 1) * 1440));
			//			Текст.reminders.overrides.Добавить(Оповещение);				
			//		КонецЕсли; 					 				
			//	КонецЦикла; 		
			//КонецЕсли; 
			
			//Если Повторяется = "Каждый год" Тогда
			//	Текст.recurrence.Добавить("RRULE:FREQ=YEARLY");//"RRULE:FREQ=DAILY;COUNT=5" каждый день 5 раз
			//КонецЕсли; 
			
			ТекстJSON = СформироватьСтрокуJSON(Текст);			
			//ТекстJSON = JSON(Текст);			
			ФайлJSON.ЗаписатьСтроку(ТекстJSON);			
			ФайлJSON.Закрыть();
			
			МассивФайлов.Добавить(ИмяВременногоФайла); 			
			ИмяФайлаОтправки = КаталогВременныхФайлов() + Boundary + ".txt";          		
			ОбъединитьФайлы(МассивФайлов, ИмяФайлаОтправки);
			
		Исключение
			Сообщить("Не удалось сохранить файл отправки: " + ОписаниеОшибки());
			Возврат;
		КонецПопытки;
		
		
		Заголовоки = Новый Соответствие();  
		Заголовоки.Вставить("Content-Type", "application/json; charset=UTF-8" );
		Заголовоки.Вставить("cache-control", "no-cache, no-store, max-age=0, must-revalidate" );
		ФайлОтправки = Новый Файл(ИмяФайлаОтправки);
		Заголовоки.Вставить("Content-Length", XMLСтрока(ФайлОтправки.Размер()));
		
		Соединение = Новый HTTPСоединение("www.googleapis.com",,,,,Истина);
		
		Попытка
			ЗапросHTTP = Новый HTTPЗапрос;
			ЗапросHTTP.АдресРесурса = "/calendar/v3/calendars/" + КодироватьСтрокуНаСервере(ИдКалендаря, "КодировкаURL") + "/events?access_token=" + Гугл_access_token;
			ЗапросHTTP.Заголовки = Заголовоки;
			ЗапросHTTP.УстановитьИмяФайлаТела(ИмяФайлаОтправки); 
			
			ОтветHTTP = Соединение.ОтправитьДляОбработки(ЗапросHTTP);
		Исключение
			Сообщить("Ошибка соединения с www.googleapis.com: " + ОписаниеОшибки());
			Возврат;
		КонецПопытки;
		Ответ = ОтветHTTP.ПолучитьТелоКакСтроку();
		
		Соединение = Неопределено;
		ЗапросHTTP = Неопределено;
		
		УдалитьФайлы(ИмяФайлаОтправки);
		
		Для каждого ЭлементМассива Из МассивФайлов Цикл
			УдалитьФайлы(ЭлементМассива);
		КонецЦикла;
		
		ПолучитьСобытияИзОтвета(Ответ, НаименованиеКалендаря);
		
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Функция СформироватьСписокУроков()
	
	Если ЗначениеЗаполнено(ПериодВыгрузки.ДатаНачала) Тогда 		
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	Урок.Ссылка КАК Ссылка
		|ИЗ
		|	Документ.LM_Урок КАК Урок
		|ГДЕ
		|	Урок.Проведен = ИСТИНА
		|	И Урок.Дата МЕЖДУ &ДатаНачала И &ДатаОкончания";
		Запрос.УстановитьПараметр("ДатаНачала", ПериодВыгрузки.ДатаНачала);
		Запрос.УстановитьПараметр("ДатаОкончания", КонецДня(ПериодВыгрузки.ДатаОкончания));
	Иначе
		Сообщить("Не выбран период выгрузки!");
		//Запрос = Новый Запрос;
		//Запрос.Текст = 
		//"ВЫБРАТЬ ПЕРВЫЕ 100
		//|	Урок.Ссылка КАК Ссылка
		//|ИЗ
		//|	Документ.Урок КАК Урок
		//|ГДЕ
		//|	Урок.Проведен = ИСТИНА";
	КонецЕсли;
	
	ТЗУроки = Запрос.Выполнить().Выгрузить();
	
	Возврат ТЗУроки;
	
КонецФункции



&НаСервере
Функция Транслит(Вход) 
	Коды = Новый Соответствие;
	Коды.Вставить("ё","yo");
	Коды.Вставить("Ё","Yo");
	Нач = КодСимвола("А");
	Англ = "A" "B" "V" "G" "D" "E" "Zh" "Z" "I" "Y" "K" "L" "M" "N" "O" "P" "R" "S" "T" "U" "F" "Kh" "Ts" "Ch" "Sh" "Shch" "" "Y" "" "E" "Yu" "Ya" "a" "b" "v" "g" "d" "e" "zh" "z" "i" "y" "k" "l" "m" "n" "o" "p" "r" "s" "t" "u" "f" "kh" "ts" "ch" "sh" "shch" "" "y" "" "e" "yu" "ya";
	Для К = Нач по КодСимвола("я") Цикл
		Коды.Вставить(Символ(К), СтрПолучитьСтроку(Англ, К - Нач + 1));
	КонецЦикла;
	Выход = "";
	Для К=1 по СтрДлина(Вход) Цикл
		Бкв = Сред(Вход,К,1);
		Зн = Коды.Получить(Бкв);
		Выход = Выход + ?(Зн = Неопределено, Бкв, Зн);
	КонецЦикла;
	Возврат Выход;        	
КонецФункции

&НаКлиенте
Процедура СоздатьНапоминанияДняРождения(Команда)
	
	ТекущийКалендарь = Элементы.Календари.ТекущиеДанные;
	
	Если ТекущийКалендарь.ТолькоПросмотр Тогда
		Сообщить("В этот календарь записывать события нельзя! Выберите другой календарь.");
		Возврат;	
	КонецЕсли;
	
	//КоличествоСтрок = 1;
	//НомерСтроки = 1;
	
	//Состояние("" + НомерСтроки + " из " + КоличествоСтрок + " " + Строка.Имя);
	//НомерСтроки = НомерСтроки + 1;
	//Структура = Новый Структура("Имя, День, Месяц, СсылкаНаСтраницу, ДатаРождения, НаименованиеСобытия", 
	//"Вася",//Строка.Имя,
	//"День",//Строка.День,
	//"Месяц",//Строка.Месяц, 
	//"СсылкаНаСтраницу",//Строка.СсылкаНаСтраницу,
	//"ДатаРождения",//Строка.ДатаРождения,
	//"НаименованиеСобытия");//Строка.НаименованиеСобытия); 
	
	СоздатьНапоминанияДняРожденияНаСервере(ТекущийКалендарь.ИД, ТекущийКалендарь.Наименование);
	
	События.Сортировать("ДатаНачала");
	//ПодключитьОбработчикОжидания("ИзменитьЦветПоля", 10, Истина);
	
КонецПроцедуры

&НаКлиенте
Процедура СобытияВыбор(Элемент, ВыбраннаяСтрока, Поле, СтандартнаяОбработка)
	Если Элемент.ТекущийЭлемент.Имя = "СобытияhtmlLink" Тогда  	
		ЗапуститьПриложение(Элемент.ТекущиеДанные.htmlLink);
	КонецЕсли; 
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	НастройкиПоУмолчанию();
	ПолеHTMLДокумента = "
	|<!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Strict//EN"" ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"">
	|<html xmlns=""http://www.w3.org/1999/xhtml"" lang=""ru"" xml:lang=""ru"">
	|<head>
	| <meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"" />
	| <title>Документ без названия</title>
	| <link rel=""stylesheet"" type=""text/css"" href=""style.css"" media=""all"" />
	|</head>
	|<body>
	|<iframe frameborder=""0"" allowtransparency=""true"" scrolling=""no"" src=""https://money.yandex.ru/embed/donate.xml?account=410012602817240&quickpay=donate&payment-type-choice=on&default-sum=100&targets=%D0%9E%D1%82%D0%B1%D0%BB%D0%B0%D0%B3%D0%BE%D0%B4%D0%B0%D1%80%D0%B8%D1%82%D1%8C+%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D0%B0&target-visibility=on&project-name=&project-site=&button-text=03&successURL="" width=""498"" height=""104""></iframe>
	|</body>
	|</html>";
	
	ПериодВыгрузкиПриИзмененииНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура НастройкиПоУмолчанию(Перезаполнить = Ложь)
	Если ГуглКлиентИд = "" Или Перезаполнить Тогда		
		ГуглКлиентИд = "953010898663-nfthn853j7r5vg43r5g2tgttnvj6ocng.apps.googleusercontent.com";
	КонецЕсли; 
	Если ГуглРедиректУРЛ = "" Или Перезаполнить Тогда		
		ГуглРедиректУРЛ = "urn:ietf:wg:oauth:2.0:oob";
	КонецЕсли; 
	Если Гугл_client_secret = "" Или Перезаполнить Тогда		
		Гугл_client_secret = "_T_qcLtlKKQIynJx-7p6aWul";
	КонецЕсли; 
	Если timeZone = "" Или Перезаполнить Тогда		
		timeZone = "Europe/Moscow";
	КонецЕсли; 
	Если Повторяется = "" Или Перезаполнить Тогда		
		Повторяется = "Каждый год";
	КонецЕсли; 
	Если ТипыОповещения.Количество() = 0 Или Перезаполнить Тогда
		Если Перезаполнить Тогда
			ТипыОповещения.Очистить();	
		КонецЕсли; 
		НоваяСтрока = ТипыОповещения.Добавить();
		НоваяСтрока.method = "sms";
		НоваяСтрока.minutes = 900; //15 часов
		НоваяСтрока.День = 1;
		НоваяСтрока.Время = '00010101090000';
	КонецЕсли; 
	ПовторяющееМероприятие = Истина;
	УказыватьДатуРожденияВНаименованииСобытия = Истина;
	УказыватьСсылкуНаСтраницуПользователяВНаименованииСобытия = Истина;	
КонецПроцедуры // НастройкиПоУмолчанию()

&НаКлиенте
Процедура ИспользоватьНастройкиОповещенияПоУмолчаниюПриИзменении(Элемент)
	Элементы.ТипыОповещения.Доступность = Не ИспользоватьНастройкиОповещенияПоУмолчанию;
	Элементы.ТекстОповещения.Доступность = Не ИспользоватьНастройкиОповещенияПоУмолчанию;
КонецПроцедуры

&НаКлиенте
Процедура ПовторяющееМероприятиеПриИзменении(Элемент)
	Элементы.Повторяется.Доступность = ПовторяющееМероприятие;
КонецПроцедуры

&НаКлиенте
Процедура ТипыОповещенияПередНачаломДобавления(Элемент, Отказ, Копирование, Родитель, Группа, Параметр)
	Если ТипыОповещения.Количество() = 5 Тогда
		Отказ = Истина;
		Предупреждение("Больше 5 нельзя!");
	КонецЕсли; 
КонецПроцедуры

&НаКлиенте
Процедура КалендариПриАктивизацииСтроки(Элемент)
	Если Не Календари.Количество() = 0 Тогда 	
		Элементы.События.ОтборСтрок = Новый ФиксированнаяСтруктура(Новый Структура("Календарь", Элементы.Календари.ТекущиеДанные.Наименование));
	КонецЕсли; 
КонецПроцедуры

&НаКлиенте
Процедура КонсольРазработчикаГуглНажатие(Элемент)
	ЗапуститьПриложение(Элементы.КонсольРазработчикаГугл.Заголовок);
КонецПроцедуры

&НаКлиенте
Процедура Декорация1Нажатие(Элемент)
	ЗапуститьПриложение("https://accounts.google.com/SignUp");
КонецПроцедуры

&НаКлиенте
Процедура Декорация4Нажатие(Элемент)
	ЗапуститьПриложение("https://www.google.com/calendar");
КонецПроцедуры

&НаКлиенте
Процедура СобытияПриАктивизацииСтроки(Элемент)
	Если Не События.Количество() = 0 Тогда
		Элементы.ТипыОповещенияСобытия.ОтборСтрок = Новый ФиксированнаяСтруктура(Новый Структура("Событие", ?(Элементы.События.ТекущиеДанные = Неопределено, "--", Элементы.События.ТекущиеДанные.ИД)));
		//ТекущиеДанные = Элементы.События.ТекущиеДанные;
		//Если ТекущиеДанные = Неопределено Тогда
		//    Возврат;	
		//КонецЕсли; 
		//Попытка
		//    МассивСтрок = СписокДрузей.НайтиСтроки(Новый Структура("НаименованиеСобытия", ТекущиеДанные.Наименование));
		//	Если МассивСтрок.Количество() = 0 Тогда
		//	    Возврат;		
		//	КонецЕсли; 
		//	Элементы.СписокДрузей.ТекущаяСтрока = СписокДрузей.Индекс(МассивСтрок[0]);
		//Исключение
		//КонецПопытки;
	КонецЕсли; 
КонецПроцедуры 

&НаСервере
Функция JSON(Значение) Экспорт
	СоответствиеХМЛ = Новый Соответствие;	
	//	СоответствиеХМЛ.Вставить(Тип(<Тип этой 1С базы>),<Тип 1С базы получателя>);
	СоответствиеХМЛ.Вставить(Тип("Дата"),"Дата");
	СоответствиеХМЛ.Вставить(Тип("ВидДвиженияНакопления"),"ВидДвиженияНакопления");
	СоответствиеХМЛ.Вставить(Тип("ДвоичныеДанные"),"ДвоичныеДанные");
	СоответствиеХМЛ.Вставить(Тип("ХранилищеЗначения"),"ХранилищеЗначения");
	СоответствиеХМЛ.Вставить(Тип("УникальныйИдентификатор"),"УникальныйИдентификатор");
	СоответствиеХМЛ.Вставить(Тип("ВидСчета"),"ВидСчета");
	//	СоответствиеХМЛ.Вставить(Тип("ДокументСсылка.Поступление"),"ДокументСсылка.ПоступлениеТоваровУслуг");
	
	СоответствиеОбъектов = Новый Соответствие;	
	//  ДЛЯ УКАЗАННЫХ ТУТ ОБЪЕКТОВ ОБЯЗАТЕЛЬНО УКАЗАНИЕ СООТВЕТСТВИЯ ССЫЛОК В СТРУКТУРЕ СоответствиеХМЛ	
	//	СоответствиеОбъектов.Вставить(Тип(<Тип объекта этой 1С базы>),<Конструктор нового объекта базы получателя>);
	//	СоответствиеОбъектов.Вставить(Тип("ДокументОбъект.Поступление"),"Документы.ПоступлениеТоваровУслуг.СоздатьДокумент()");
	
	СтруктураТипов = Новый Структура("СоответствиеХМЛ,СоответствиеОбъектов,SAVE",СоответствиеХМЛ,СоответствиеОбъектов,Истина);
	Возврат НеФорматированныйJSON(Значение,СтруктураТипов);	
КонецФункции

&НаСервере
Функция UnJSON(СтрJSON) Экспорт
	Перем Значение;
	
	Если ПолучитьЗначениеJSON(СтрJSON,Значение)=0 Тогда
		Возврат Значение
	КонецЕсли;
	Возврат Неопределено
КонецФункции

//В функции конструкции условий расставлены по частоте их использования.
//Если кому нибудь удастся более оптимально (в смысле быстродействия) написать,
//то просьба сообщить мне на bigb.forum@gmail.com
&НаСервере
Функция НеФорматированныйJSON(Значение,СтруктураТипов=Неопределено)
	
	Если СтруктураТипов=Неопределено Тогда
		СоответствиеХМЛ = Новый Соответствие;
		СоответствиеОбъектов  = Новый Соответствие;
		СтруктураТипов = Новый Структура("СоответствиеХМЛ,СоответствиеОбъектов",СоответствиеХМЛ,СоответствиеОбъектов);
	Иначе
		СоответствиеХМЛ = СтруктураТипов.СоответствиеХМЛ;
		СоответствиеОбъектов  = СтруктураТипов.СоответствиеОбъектов;
	КонецЕсли; 
	
	Разделитель="";
	
	ТипЗн=ТипЗнч(Значение);
	
	Если ТипЗн=Тип("Строка") Тогда
		Стр=""""+Экранировать(Значение)+""""
		
	ИначеЕсли ТипЗн=Тип("Число") ИЛИ ТипЗнч(Значение)=Тип("Булево") Тогда
		Стр=XMLСтрока(Значение)
		
		//ИначеЕсли ТипЗн=Тип("Дата") Тогда
		//	Стр=""""+?(ЗначениеЗаполнено(Значение),XMLСтрока(Значение),"")+""""
		
	ИначеЕсли ТипЗн=Тип("Структура") Тогда
		Стр="{";
		Для Каждого Параметр Из Значение Цикл
			Стр=Стр+Разделитель+Символы.ПС+""""+Параметр.Ключ+""":"+НеФорматированныйJSON(Параметр.Значение,СтруктураТипов);
			Разделитель=","
		КонецЦикла;
		Стр=Стр+Символы.ПС+"}";
		
	ИначеЕсли ТипЗн=Тип("Массив") Тогда
		Стр="[";
		Для Каждого Элемент Из Значение Цикл
			Стр=Стр+Разделитель+Символы.ПС+НеФорматированныйJSON(Элемент,СтруктураТипов);
			Разделитель=","
		КонецЦикла;
		Стр=Стр+Символы.ПС+"]";
		
	ИначеЕсли ТипЗн=Тип("ТаблицаЗначений") Тогда
		Колонки=Значение.Колонки;
		СтруктураТЗ = Новый Структура;
		СтруктураТЗ.Вставить("TYPE","ТаблицаЗначений");
		СтруктураТЗ.Вставить("COLUMNS",Новый Структура);
		СтруктураТЗ.Вставить("ROWS",Новый Массив);
		Для Каждого Колонка Из Колонки Цикл
			СтруктураТЗ.COLUMNS.Вставить(Колонка.Имя,);
		КонецЦикла;
		Для Каждого СтрокаТЗ Из Значение Цикл
			Структура=Новый Структура;
			Для Каждого Колонка Из Колонки Цикл
				Структура.Вставить(Колонка.Имя,СтрокаТЗ[Колонка.Имя])
			КонецЦикла;
			СтруктураТЗ.ROWS.Добавить(Структура);
		КонецЦикла;
		Стр=НеФорматированныйJSON(СтруктураТЗ,СтруктураТипов)
		
	ИначеЕсли Значение=Неопределено Тогда
		Стр="null"
		
	ИначеЕсли СоответствиеХМЛ.Получить(ТипЗн) <> Неопределено Тогда
		
		ЗначениеСтруктурой = Новый Структура("TYPE,UID",СоответствиеХМЛ.Получить(ТипЗн),XMLСтрока(Значение));
		Стр=НеФорматированныйJSON(ЗначениеСтруктурой,СтруктураТипов)
		
	ИначеЕсли СоответствиеОбъектов.Получить(ТипЗн) <> Неопределено Тогда
		
		ЗначениеСтруктурой = Новый Структура("OBJECT,NEW",Истина,СоответствиеОбъектов.Получить(ТипЗн));
		ЗначениеСтруктурой.Вставить("SAVE",СтруктураТипов.Свойство("SAVE") И СтруктураТипов.SAVE = Истина);
		
		//Значение = Документы.Поступление.НайтиПоНомеру("000000001").ПолучитьОбъект();
		МетаданныеЗначения = Значение.Метаданные();
		
		Для каждого СтандартныйРеквизит Из МетаданныеЗначения.СтандартныеРеквизиты Цикл
			ЗначениеСтруктурой.Вставить(СтандартныйРеквизит.Имя,Значение[СтандартныйРеквизит.Имя]);
		КонецЦикла; 
		Для каждого Реквизит Из МетаданныеЗначения.Реквизиты Цикл
			ЗначениеСтруктурой.Вставить(Реквизит.Имя,Значение[Реквизит.Имя]);
		КонецЦикла; 
		Для каждого ТабличнаяЧасть Из МетаданныеЗначения.ТабличныеЧасти Цикл
			ЗначениеСтруктурой.Вставить(ТабличнаяЧасть.Имя,Значение[ТабличнаяЧасть.Имя].Выгрузить());
		КонецЦикла; 
		Стр=НеФорматированныйJSON(ЗначениеСтруктурой,СтруктураТипов)
	Иначе
		Стр=""""+Экранировать(Значение)+""""
	КонецЕсли;
	
	Возврат Стр
КонецФункции

&НаСервере
Функция ПолучитьЗначениеJSON(СтрJSON,Значение,Позиция=1,Ключ="")
	Перем Кавычка;
	
	ЗначениеВСтроке="";
	Кавычек=0;
	Комментарий=Ложь;
	Строка=Ложь;
	
	Пока Позиция<=СтрДлина(СтрJSON) Цикл
		ХХ=Сред(СтрJSON,Позиция,2);
		Х=Лев(ХХ,1);
		Позиция=Позиция+1;
		
		Если Х>" " ИЛИ Строка Тогда //Отсекаем всякий хлам
			
			Если Комментарий Тогда
				//Это комментарий. Крутимся в цикле пока не встретится конец комментария
				Если ХХ="*/" Тогда
					//Комментарий закончился
					Комментарий=Ложь;
					Позиция=Позиция+1;
				КонецЕсли;
				
			ИначеЕсли Х="\" Тогда
				Позиция=Позиция+1;
				ХХ=ВРег(ХХ);
				Если ХХ="\""" Тогда ЗначениеВСтроке=ЗначениеВСтроке+""""
				ИначеЕсли ХХ="\\" Тогда ЗначениеВСтроке=ЗначениеВСтроке+"\"
				ИначеЕсли ХХ="\/" Тогда ЗначениеВСтроке=ЗначениеВСтроке+"/"
				ИначеЕсли ХХ="\B" Тогда ЗначениеВСтроке=ЗначениеВСтроке+Символ(8)
				ИначеЕсли ХХ="\F" Тогда ЗначениеВСтроке=ЗначениеВСтроке+Символы.ПФ //перевод формы (страницы)
				ИначеЕсли ХХ="\N" Тогда ЗначениеВСтроке=ЗначениеВСтроке+Символы.ПС //перевод строки
				ИначеЕсли ХХ="\R" Тогда ЗначениеВСтроке=ЗначениеВСтроке+Символы.ВК //возврат каретки
				ИначеЕсли ХХ="\T" Тогда ЗначениеВСтроке=ЗначениеВСтроке+Символы.ВТаб //символ вертикальной табуляции
				ИначеЕсли ХХ="\U" Тогда
					ЗначениеВСтроке=ЗначениеВСтроке+Символ(Hex2Число(Сред(СтрJSON,Позиция,4))); //шестнадцатиричное число
					Позиция=Позиция+4
				КонецЕсли;
				
			ИначеЕсли Строка Тогда
				//Если строка не закончилась - то пропускаем управляющие символы
				Если Х=Кавычка Тогда
					//Закончилась строка
					Строка=Ложь;
					Кавычек=Кавычек+1;
				Иначе
					ЗначениеВСтроке=ЗначениеВСтроке+Х;
				КонецЕсли;
				
			ИначеЕсли ХХ="/*" Тогда
				//Начался комментарий
				Комментарий=Истина;
				Позиция=Позиция+1;
				
			ИначеЕсли Найти("""'{}[]:,",Х)>0 Тогда
				Если Х="""" ИЛИ Х="'" Тогда
					//Началась строка
					//Строка - коллекция нуля или больше символов Unicode, заключенная в
					//двойные кавычки, используя "\" в качестве символа экранирования.
					//Символ представляется как односимвольная строка.
					//Похожий синтаксис используется в C и Java.
					Строка=Истина;
					Кавычка=Х;
					Кавычек=Кавычек+1;
					
				ИначеЕсли Х="{" Тогда
					//Начался объект
					//Объект - неупорядоченный набор пар ключ/значение.
					//Объект начинается с "{" и заканчивается "}".
					//Каждое имя сопровождается ":", пары ключ/значение разделяются ",".
					ОбъектСтруктура=Новый Структура;
					//Объект=Новый Структура;
					Пока Истина Цикл
						//Получим ключ и значение
						Ключ="";
						Режим=ПолучитьЗначениеJSON(СтрJSON,Значение,Позиция,Ключ);
						//0 - есть значение и не конец объекта (запятая)
						//1 - есть значение и конец объекта
						//2 - нет значения и не конец объекта (запятая)
						//3 - нет значения и конец объекта
						Если Режим=0 Тогда
							ОбъектСтруктура.Вставить(Ключ,Значение);
						ИначеЕсли Режим=1 Тогда
							ОбъектСтруктура.Вставить(Ключ,Значение);
							Прервать
						ИначеЕсли Режим=3 Тогда
							Прервать
						КонецЕсли;
					КонецЦикла;
					Если ОбъектСтруктура.Свойство("UID") Тогда
						//Это простой ХМЛ тип
						//Значение = XMLЗначение(Тип(ОбъектСтруктура.TYPE),ОбъектСтруктура.UID);
						Значение = ОбъектСтруктура;
					ИначеЕсли ОбъектСтруктура.Свойство("OBJECT") Тогда
						//Это объект
						//Получаем объект
						ОбъектИБ = ОбъектСтруктура.Ссылка.ПолучитьОбъект();
						Если ОбъектИБ = Неопределено Тогда
							//Если объекта нет, то создать
							ОбъектИБ = Вычислить(ОбъектСтруктура.NEW); 
							ОбъектИБ.УстановитьСсылкуНового(ОбъектСтруктура.Ссылка);
						КонецЕсли; 
						//Заполнить реквизиты
						ЗаполнитьЗначенияСвойств(ОбъектИБ,ОбъектСтруктура);
						
						//Определить ТЧ и попытаться заполнить
						МетаданныеЗначения = ОбъектИБ.Метаданные();
						Для каждого ТабличнаяЧасть Из МетаданныеЗначения.ТабличныеЧасти Цикл
							Если ОбъектСтруктура.Свойство(ТабличнаяЧасть.Имя) И ТипЗнч(ОбъектСтруктура[ТабличнаяЧасть.Имя]) = Тип("ТаблицаЗначений") Тогда
								ОбъектИБ[ТабличнаяЧасть.Имя].Загрузить(ОбъектСтруктура[ТабличнаяЧасть.Имя]);
							Иначе 
								ОбъектИБ[ТабличнаяЧасть.Имя].Очистить();
							КонецЕсли; 
						КонецЦикла;
						Если ОбъектСтруктура.Свойство("SAVE") И ОбъектСтруктура.SAVE = Истина Тогда
							ОбъектИБ.ОбменДанными.Загрузка = Истина;
							ОбъектИБ.Записать();
							Сообщение = Новый СообщениеПользователю;
							Сообщение.Текст = "Записан объект "+ОбъектИБ;
							Сообщение.КлючДанных = ОбъектСтруктура.Ссылка;
							Сообщение.Сообщить(); 
						КонецЕсли; 
						Значение = ОбъектИБ;
					ИначеЕсли ОбъектСтруктура.Свойство("TYPE") Тогда
						Если ОбъектСтруктура.TYPE = "ТаблицаЗначений" Тогда
							//Это таблица
							СтруктураТЗ = Новый Структура;
							ТаблицаРезультата = Новый ТаблицаЗначений;
							Для каждого Колонка Из ОбъектСтруктура.COLUMNS Цикл
								ТаблицаРезультата.Колонки.Добавить(Колонка.Ключ);
							КонецЦикла; 
							Для каждого СтрокаТаблицы Из ОбъектСтруктура.ROWS Цикл
								НоваяСтрока = ТаблицаРезультата.Добавить();
								ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаТаблицы);
							КонецЦикла; 
							Значение= ТаблицаРезультата;
						Иначе
							//Сюда мы попадать не должны
							Сообщить("Тип не определен:"+ОбъектСтруктура.TYPE);
						КонецЕсли; 
					Иначе
						//Иначе это обычная структура
						Значение = ОбъектСтруктура;
					КонецЕсли; 
					Возврат 0
				ИначеЕсли Х="[" Тогда
					//Начался массив
					//Массив - упорядоченная коллекция значений.
					//Массив начинается с "[" и заканчивается "]".
					//Значения разделены ",".
					Массив=Новый Массив;
					Пока Истина Цикл
						Режим=ПолучитьЗначениеJSON(СтрJSON,Значение,Позиция);
						//0 - есть значение и не конец массива (запятая)
						//1 - есть значение и конец массива
						//2 - нет значения и не конец массива (запятая)
						//3 - нет значения и конец массива
						Если Режим=0 Тогда
							Массив.Добавить(Значение);
						ИначеЕсли Режим=1 Тогда
							Массив.Добавить(Значение);
							Прервать
						ИначеЕсли Режим=3 Тогда
							Прервать
						КонецЕсли;
					КонецЦикла;
					Если Массив.Количество() > 0 И ТипЗнч(Массив[0])=Тип("Структура") Тогда
						//Если мы получили массив структур, то это таблица
						ТаблицаРезультата = Новый ТаблицаЗначений;
						Для каждого Колонка Из Массив[0] Цикл
							ТаблицаРезультата.Колонки.Добавить(Колонка.Ключ);
						КонецЦикла; 
						Для каждого СтрокаТаблицы Из Массив Цикл
							НоваяСтрока = ТаблицаРезультата.Добавить();
							ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаТаблицы);
						КонецЦикла; 
						Значение= ТаблицаРезультата;
					Иначе
						Значение=Массив;
					КонецЕсли; 
					Возврат 0
				ИначеЕсли Х="]" ИЛИ Х="}" Тогда
					//Закончился массив/объект
					Если ЗначениеВСтроке="" И Кавычек=0 Тогда
						Возврат 3 //нет значения и конец массива/объекта
					Иначе
						Значение=ПолучитьЗначениеИзСтроки(ЗначениеВСтроке,Кавычек);
						Возврат 1 //есть значение и конец массива/объекта
					КонецЕсли;
				ИначеЕсли Х=":" Тогда
					Ключ=ЗначениеВСтроке;
					Возврат ПолучитьЗначениеJSON(СтрJSON,Значение,Позиция);
					
				Иначе
					// запятая
					Прервать
				КонецЕсли;
				
			Иначе
				ЗначениеВСтроке=ЗначениеВСтроке+Х;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если Кавычек>0 Тогда
		Значение=ЗначениеВКавычках(ЗначениеВСтроке);
	Иначе
		Если ЗначениеВСтроке="" Тогда
			Возврат 2
		Иначе
			Значение=ЗначениеБезКавычек(ЗначениеВСтроке)
		КонецЕсли;
	КонецЕсли;
	Возврат 0
КонецФункции

&НаСервере
Функция Hex2Число(Hex) Экспорт
	Стр=ВРег(СокрЛП(Hex));
	Dec=0;
	Для Х=1 По СтрДлина(Стр) Цикл
		Dec=Dec+Найти("123456789ABCDEF",Сред(Стр,Х,1))*Pow(16,СтрДлина(Стр)-Х)
	КонецЦикла;
	Возврат Dec
КонецФункции

&НаСервере
Функция ПолучитьЗначениеИзСтроки(ЗначениеВСтроке,Кавычек)
	Если Кавычек>0 Тогда
		Возврат ЗначениеВКавычках(ЗначениеВСтроке)
	ИначеЕсли ЗначениеВСтроке="" Тогда
		Возврат Неопределено
	КонецЕсли;
	Возврат ЗначениеБезКавычек(ЗначениеВСтроке)
КонецФункции

&НаСервере
Функция ЗначениеВКавычках(ЗначениеВСтроке)
	//Это или строка или дата.
	//Дата пока не обрабатывается (потом надо дописать)
	//Пока всегда возвращаем просто строку
	Возврат ЗначениеВСтроке
КонецФункции

&НаСервере
Функция ЗначениеБезКавычек(ЗначениеВСтроке)
	//Это число, булево или null.
	//Хотя здесь могут быть и строки. Например: {Code:123}
	Стр=ВРег(ЗначениеВСтроке);
	Если Стр="TRUE" Тогда Возврат Истина
	ИначеЕсли Стр="FALSE" Тогда Возврат Ложь
	ИначеЕсли Стр="NULL" Тогда Возврат Неопределено
	КонецЕсли;
	
	//Пробежимся по предполагаемому "числу"
	Экспонента=Ложь;
	ХХ=" ";
	Для Индекс=1 По СтрДлина(Стр) Цикл
		Х=Сред(Стр,Индекс,1);
		Если Найти("0123456789.+-",Х) Тогда
			ХХ=ХХ+Х
		ИначеЕсли Х="E" Тогда
			Экспонента=Истина;
			УУ=XMLЗначение(Тип("Число"),ХХ);
			ХХ=" ";
		Иначе
			Возврат ЗначениеВСтроке //Это точно не число, а строка
		КонецЕсли;
	КонецЦикла;
	
	ХХ=XMLЗначение(Тип("Число"),ХХ);
	Если Экспонента Тогда
		ХХ=УУ*Pow(10,ХХ)
	КонецЕсли;
	
	Возврат ХХ
КонецФункции

&НаСервере
Функция Экранировать(Стр)
	Х=СтрЗаменить(Стр,"""","\""");
	//Х=СтрЗаменить(Х,"'","\'"); //??? Не уверен в этой строке. Кто нибудь может подтвердить или опровергнуть нужность этой строки.
	Х=СтрЗаменить(Х,"\","\\");
	Х=СтрЗаменить(Х,"/","\/"); //Тут тоже не уверен, но пока оставлю.
	Х=СтрЗаменить(Х,Символ(8),"\b");
	Х=СтрЗаменить(Х,Символы.ПФ,"\f");
	Х=СтрЗаменить(Х,Символы.ПС,"\n");
	Х=СтрЗаменить(Х,Символы.ВК,"\r");
	Х=СтрЗаменить(Х,Символы.ВТаб,"\t");
	Возврат Х
КонецФункции

&НаСервере
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1 = 1 Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр, Поз - 1));
			Стр = СокрЛ(Сред(Стр, Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1 = 1 Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				Если (СокрЛП(Стр) <> "") Тогда
					МассивСтрок.Добавить(Стр);
				КонецЕсли;
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз - 1));
			Стр = Сред(Стр, Поз + ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции 

&НаСервере
Функция ПреобразоватьвСистему(Число10,система) Экспорт
	
	Если система > 36 или система < 2 тогда
		Сообщить("Выбранная система исчисления не поддерживается");
		Возврат -1;
	КонецЕсли;
	
	СтрокаЗначений = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	СтрокаСистема = "";
	Пока Число10 > 0 цикл
		РезДеления = Число10/система;
		ЧислоСистема = цел(РезДеления);
		остатокОтДеления = Число10 - система*(ЧислоСистема);
		СтрокаСистема = сред(СтрокаЗначений,остатокОтДеления+1,1)+ СтрокаСистема;
		Число10 = ?(ЧислоСистема=0,0,РезДеления); 
	КонецЦикла;
	
	Нечётное = стрДлина(СтрокаСистема) - цел(стрДлина(СтрокаСистема)/2)*2;
	Если Нечётное тогда
		СтрокаСистема = "0"+СтрокаСистема;
	КонецЕсли;
	
	Возврат СтрокаСистема;
	
КонецФункции

&НаСервере
Функция URLEncode(стр) Экспорт	
	
	Длина=СтрДлина(Стр);
	Итог="";
	Для Н=1 По Длина Цикл
		Знак=Сред(Стр,Н,1);
		Код=КодСимвола(Знак);
		
		если ((Знак>="a")и(Знак<="z")) или
			((Знак>="A")и(Знак<="Z")) или
			((Знак>="0")и(Знак<="9")) тогда
			Итог=Итог+Знак;
		Иначе
			Если (Код>=КодСимвола("А"))И(Код<=КодСимвола("п")) Тогда
				Итог=Итог+"%"+ПреобразоватьвСистему(208,16)+"%"+ПреобразоватьвСистему(144+Код-КодСимвола("А"),16);
			ИначеЕсли (Код>=КодСимвола("р"))И(Код<=КодСимвола("я")) Тогда
				Итог=Итог+"%"+ПреобразоватьвСистему(209,16)+"%"+ПреобразоватьвСистему(128+Код-КодСимвола("р"),16);
			ИначеЕсли (Знак="ё") Тогда
				Итог=Итог+"%"+ПреобразоватьвСистему(209,16)+"%"+ПреобразоватьвСистему(145,16);
			ИначеЕсли (Знак="Ё") Тогда
				Итог=Итог+"%"+ПреобразоватьвСистему(208,16)+"%"+ПреобразоватьвСистему(129,16);
			Иначе
				Итог=Итог+"%"+ПреобразоватьвСистему(Код,16);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Итог;
	
КонецФункции

&НаСервере
Функция СформироватьСтрокуJSONИзМассива(Объект)
	
	СтрокаJSON = "[";
	
	Для каждого Элемент Из Объект Цикл
		
		Если ТипЗнч(Элемент) = Тип("Строка") Тогда
			СтрокаJSON = СтрокаJSON + """" + Элемент + """";
			
		ИначеЕсли ТипЗнч(Элемент) = Тип("Число") Тогда
			СтрокаJSON = СтрокаJSON + СтрЗаменить(Строка(Элемент), Символы.НПП, "");
			
		ИначеЕсли ТипЗнч(Элемент) = Тип("Булево") Тогда
			СтрокаJSON = СтрокаJSON + Формат(Элемент, "БЛ=false; БИ=true");
			
		ИначеЕсли ТипЗнч(Элемент) = Тип("Дата") Тогда
			// преобразование в unixtime
			СтрокаJSON = СтрокаJSON + Формат(Элемент - Дата(1970,1,1,1,0,0), "ЧГ=0");
			
		ИначеЕсли ТипЗнч(Элемент) = Тип("Массив") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент);
			
		ИначеЕсли ТипЗнч(Элемент) = Тип("Структура") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент);
			
		ИначеЕсли ТипЗнч(Элемент) = Тип("ТаблицаЗначений") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент);
			
		Иначе
			СтрокаJSON = СтрокаJSON + """" + URLEncode(Строка(Элемент)) + """";
			
		КонецЕсли;
		
		СтрокаJSON = СтрокаJSON + ",";
	КонецЦикла;
	
	Если Прав(СтрокаJSON, 1) = "," Тогда
		СтрокаJSON = Лев(СтрокаJSON, СтрДлина(СтрокаJSON)-1);
	КонецЕсли;
	
	Возврат СтрокаJSON + "]";
	
КонецФункции

&НаСервере
Функция СформироватьСтрокуJSONИзСтруктуры(Объект)
	
	СтрокаJSON = "{";
	
	Для каждого Элемент Из Объект Цикл
		
		Если Элемент.Значение = "" Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаJSON = СтрокаJSON + """" + Элемент.Ключ + """" + ":";
		
		Если ТипЗнч(Элемент.Значение) = Тип("Строка") Тогда
			СтрокаJSON = СтрокаJSON + """" + Элемент.Значение + """";
			
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Число") Тогда
			СтрокаJSON = СтрокаJSON + СтрЗаменить(Строка(Элемент.Значение), Символы.НПП, "");
			
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Булево") Тогда
			СтрокаJSON = СтрокаJSON + Формат(Элемент.Значение, "БЛ=false; БИ=true");
			
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Дата") Тогда
			// преобразование в unixtime
			СтрокаJSON = СтрокаJSON + Формат(Элемент.Значение - Дата(1970,1,1,1,0,0), "ЧГ=0");
			
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Массив") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент.Значение);
			
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("Структура") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент.Значение);
			
		ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("ТаблицаЗначений") Тогда
			СтрокаJSON = СтрокаJSON + СформироватьСтрокуJSON(Элемент.Значение);
			
		Иначе
			СтрокаJSON = СтрокаJSON + """" + URLEncode(Строка(Элемент.Значение)) + """";
			
		КонецЕсли;
		
		СтрокаJSON = СтрокаJSON + ",";
		
	КонецЦикла;
	
	Если Прав(СтрокаJSON, 1) = "," Тогда
		СтрокаJSON = Лев(СтрокаJSON, СтрДлина(СтрокаJSON)-1);
	КонецЕсли;
	
	Возврат СтрокаJSON + "}";
	
КонецФункции

&НаСервере
Функция СформироватьСтрокуJSON(Объект) Экспорт
	
	СтрокаJSON = "";
	
	Если ТипЗнч(Объект) = Тип("Массив") Тогда
		СтрокаJSON = СформироватьСтрокуJSONИзМассива(Объект);
		
	ИначеЕсли ТипЗнч(Объект) = Тип("Структура") Тогда
		СтрокаJSON = СформироватьСтрокуJSONИзСтруктуры(Объект);
		
	ИначеЕсли ТипЗнч(Объект) = Тип("ТаблицаЗначений") Тогда
		// преобразуем таблицу значений в массив структур - работает дольше, но кода меньше
		// если нужна скорость, то нужно отдельно обработать таблицу значений
		
		СоставСтруктуры = "";
		Для каждого Колонка Из Объект.Колонки Цикл
			СоставСтруктуры = СоставСтруктуры + ?(ЗначениеЗаполнено(СоставСтруктуры), ",", "") + Колонка.Имя;
		КонецЦикла;
		
		МассивСтрок = Новый Массив;
		Для каждого Строка Из Объект Цикл
			СтруктураКолонок = Новый Структура(СоставСтруктуры);
			ЗаполнитьЗначенияСвойств(СтруктураКолонок, Строка);
			МассивСтрок.Добавить(СтруктураКолонок);
		КонецЦикла;
		
		СтрокаJSON = СформироватьСтрокуJSONИзМассива(МассивСтрок);
		
	КонецЕсли;
	
	Возврат СтрокаJSON;
	
КонецФункции

&НаСервере
Процедура ЗаполнитьДанныеИзОтветаJSON(Результат, ТекстJSON, ТипДанных)
	
	ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));	// удалим открывающий символ структуры(массива)
	
	НомерЗначения = 0;
	
	Пока ТекстJSON <> "" Цикл
		
		ПервыйСимвол = Лев(ТекстJSON, 1);
		Если ПервыйСимвол = "{" Тогда
			// вложенная структура
			Значение = Новый Структура;
			ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Структура");
			
			Если ТипДанных = "Структура" Тогда
				Результат.Вставить("Значение" + ?(НомерЗначения = 0, "", НомерЗначения), Значение);
				НомерЗначения = НомерЗначения + 1;
			ИначеЕсли ТипДанных = "Массив" Тогда
				Результат.Добавить(Значение);
			КонецЕсли;
			
		ИначеЕсли ПервыйСимвол = "[" Тогда
			// вложенный массив
			Значение = Новый Массив;
			ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Массив");
			
			Если ТипДанных = "Структура" Тогда
				Результат.Вставить("Значение" + ?(НомерЗначения = 0, "", НомерЗначения), Значение);
				НомерЗначения = НомерЗначения + 1;
			Иначе
				Результат.Добавить(Значение);
			КонецЕсли;
			
		ИначеЕсли ПервыйСимвол = "}" И ТипДанных = "Структура" Тогда
			// структура закончилась
			ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			Если Лев(ТекстJSON, 1) = "," Тогда
				ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			КонецЕсли;
			
			Возврат;
			
		ИначеЕсли ПервыйСимвол = "]" И ТипДанных = "Массив" Тогда
			// массив закончился
			ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			Если Лев(ТекстJSON, 1) = "," Тогда
				ТекстJSON = СокрЛП(Сред(ТекстJSON, 2));
			КонецЕсли;
			
			Возврат;
			
		Иначе
			
			Если ТипДанных = "Структура" Тогда
				
				Поз = Найти(ТекстJSON, ":");
				Если Поз = 0 Тогда
					// неверный формат, прервемся
					Прервать;
				КонецЕсли;
				
				ИмяЗначения = СокрЛП(Лев(ТекстJSON, Поз-1));
				
				ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз+1));
				
				Если Лев(ТекстJSON, 1) = "{" Тогда
					// значение является структурой
					Значение = Новый Структура;
					ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Структура");
					
				ИначеЕсли Лев(ТекстJSON, 1) = "[" Тогда
					// значение является массивом
					Значение = Новый Массив;
					ЗаполнитьДанныеИзОтветаJSON(Значение, ТекстJSON, "Массив");
					
				Иначе
					// обычное значение
					Поз = 0;
					Для Сч = 1 По СтрДлина(ТекстJSON) Цикл
						Символ = Сред(ТекстJSON, Сч, 1);
						Если Символ = "," ИЛИ Символ = "]" ИЛИ Символ = "}" Тогда
							Поз = Сч;
							Прервать;
						КонецЕсли;
					КонецЦикла;
					
					Если Поз = 0 Тогда
						Значение = ТекстJSON;
						ТекстJSON = "";
						
					Иначе
						Значение = Лев(ТекстJSON, Поз-1);
						ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз + ?(Сред(ТекстJSON, Поз, 1) = ",", 1, 0)));
						
					КонецЕсли;
					
					Значение = СокрЛП(Значение);
					//Если ОбщегоНазначения.ТолькоЦифрыВСтроке(Значение) Тогда
					//	Значение = Число(Значение);
					//КонецЕсли;
					
				КонецЕсли;
				
				Результат.Вставить(СтрЗаменить(ИмяЗначения, ".", "_"), Значение);
				
			ИначеЕсли ТипДанных = "Массив" Тогда
				
				// обычное значение
				Поз = 0;
				Для Сч = 1 По СтрДлина(ТекстJSON) Цикл
					Символ = Сред(ТекстJSON, Сч, 1);
					Если Символ = "," ИЛИ Символ = "]" ИЛИ Символ = "}" Тогда
						Поз = Сч;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если Поз = 0 Тогда
					Значение = ТекстJSON;
					ТекстJSON = "";
					
				Иначе
					Значение = Лев(ТекстJSON, Поз-1);
					ТекстJSON = СокрЛП(Сред(ТекстJSON, Поз + ?(Сред(ТекстJSON, Поз, 1) = ",", 1, 0)));
					
				КонецЕсли;
				
				Значение = СокрЛП(Значение);
				
				Результат.Добавить(Значение);
				
			КонецЕсли;
			
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Функция ЗаполнитьСтруктуруИзОтветаJSON(Знач ТекстJSON, ЗменятьПробелыСПереводомСтроки = Истина) Экспорт
	
	Результат = Новый Структура;
	
	ТекстJSON = СтрЗаменить(ТекстJSON, "\""", """");	// заменим последовательность \" на "
	ТекстJSON = СтрЗаменить(ТекстJSON, """", "");		// а теперь удалим все кавычки
	
	Если ЗменятьПробелыСПереводомСтроки Тогда
		ЗапятыеСПереводомСтроки = "," + Символы.ПС;
		ТекстJSON = СтрЗаменить(ТекстJSON, ЗапятыеСПереводомСтроки, "%%%%");
		ТекстJSON = СтрЗаменить(ТекстJSON, ",", " ");
		ТекстJSON = СтрЗаменить(ТекстJSON, "%%%%", ЗапятыеСПереводомСтроки);
	КонецЕсли; 
	Если Лев(ТекстJSON, 1) = "{" Тогда
		// начало структуры
		ЗаполнитьДанныеИзОтветаJSON(Результат, ТекстJSON, "Структура");
		
	ИначеЕсли Лев(ТекстJSON, 1) = "[" Тогда
		// начало массива
		МассивДанных = Новый Массив;
		ЗаполнитьДанныеИзОтветаJSON(МассивДанных, ТекстJSON, "Массив");
		
		Результат.Вставить("Значение", МассивДанных);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Процедура ОчиститьВсеСобытия(Команда)
	
	ТекущиеДанные = Элементы.Календари.ТекущиеДанные;
	Если ТекущиеДанные.ТолькоПросмотр Тогда
	    Возврат;
	КонецЕсли;
	
	ИдКалендаря = КодироватьСтрокуНаСервере(ТекущиеДанные.Ид, "КодировкаURL");
	
	Для каждого Событие Из События Цикл
		  		
		ОбработкаПрерыванияПользователя();
		
		Если Не ТекущиеДанные.Ид = Событие.Календарь Тогда
		    Продолжить;	
		КонецЕсли;
		
		ИдСобытия = Событие.Ид;
		
		Состояние("Удаляется: " + Событие.Наименование + "
		|Прервать: Ctrl + Break"); //Unsupported content with type: application/octet-stream
		
		Попытка
			Соединение = Новый HTTPСоединение("www.googleapis.com",,,,,Истина);
			ЗапросHTTP = Новый HTTPЗапрос;
			Заголовоки = Новый Соответствие(); 
			Заголовоки.Вставить("Content-Type", "application/octet-stream");
			ЗапросHTTP.Заголовки = Заголовоки;
			ЗапросHTTP.АдресРесурса = "/calendar/v3/calendars/" + ИдКалендаря + "/clear?access_token=" + Гугл_access_token;
			
			//DELETE https://www.googleapis.com/calendar/v3/calendars/calendarId/events/eventId
			
			ОтветHTTP = Соединение.ОтправитьДляОбработки(ЗапросHTTP);
		Исключение
			Сообщить("Ошибка соединения с www.googleapis.com: " + ОписаниеОшибки());
			Возврат;  //ОтветHTTP.ПолучитьТелоКакСтроку() 
		КонецПопытки;
		
	КонецЦикла;
	
	События.Очистить();
	ТипыОповещенияСобытия.Очистить();
	
КонецПроцедуры

&НаКлиенте
Процедура ТипыОповещенияminutesПриИзменении(Элемент)
	ТекущиеДанные = Элементы.ТипыОповещения.ТекущиеДанные;
	ТекущиеДанные.Время = '00010102' - ТекущиеДанные.minutes * 60;
КонецПроцедуры

&НаКлиенте
Процедура ТипыОповещенияВремяПриИзменении(Элемент)
	ТекущиеДанные = Элементы.ТипыОповещения.ТекущиеДанные;
	ТекущиеДанные.minutes = ('00010102' - ТекущиеДанные.Время) / 60; 	
КонецПроцедуры

&НаКлиенте
Процедура ТипыОповещенияПриАктивизацииСтроки(Элемент)
	ТекущиеДанные = Элементы.ТипыОповещения.ТекущиеДанные;
	Если ТекущиеДанные = Неопределено Тогда
		Элементы.ТекстОповещения.Заголовок = "";
	Иначе                                		
		Элементы.ТекстОповещения.Заголовок = "Оповещать по " + ТекущиеДанные.method + " за " + СтрЗаменить(ЧислоПрописью(ТекущиеДанные.День,, "день,дня,дней,,,,,0"), " 00", "") + "в "  + Формат(ТекущиеДанные.Время, "ДФ=ЧЧ:мм; ДП=00:00");  	
	КонецЕсли; 	 
КонецПроцедуры

&НаКлиенте
Процедура ТипыОповещенияПриИзменении(Элемент)
	ТипыОповещенияПриАктивизацииСтроки(Элемент);
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьНастройкиПоУмолчанию(Команда)
	НастройкиПоУмолчанию(Истина);
КонецПроцедуры

&НаКлиенте
Процедура ТипыОповещенияДеньПриИзменении(Элемент)
	ТекущиеДанные = Элементы.ТипыОповещения.ТекущиеДанные;
	Если ТекущиеДанные.День = 0 Тогда
		ТекущиеДанные.День = 1;
	КонецЕсли; 
КонецПроцедуры

&НаКлиенте
Процедура ТипыОповещенияПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	ТипыОповещенияДеньПриИзменении(Элемент);
КонецПроцедуры

&НаКлиенте
Процедура ТипыОповещенияСобытияПриАктивизацииСтроки(Элемент)
	ТекущиеДанные = Элементы.ТипыОповещенияСобытия.ТекущиеДанные;
	Если ТекущиеДанные = Неопределено Тогда
		Элементы.ТекстОповещенияСобытия.Заголовок = "";
	Иначе                                		
		Элементы.ТекстОповещенияСобытия.Заголовок = "Оповещать по " + ТекущиеДанные.method + " за " + СтрЗаменить(ЧислоПрописью(ТекущиеДанные.День,, "день,дня,дней,,,,,0"), " 00", "") + "в "  + Формат(ТекущиеДанные.Время, "ДФ=ЧЧ:мм; ДП=00:00");  	
	КонецЕсли; 	
КонецПроцедуры

&НаКлиенте
Процедура УказыватьДатуРожденияВНаименованииСобытияПриИзменении(Элемент)
	Если УказыватьДатуРожденияВНаименованииСобытия Тогда
		Предупреждение("Нужно снова получить друзей из Вконтакта!");	
	КонецЕсли; 
КонецПроцедуры

&НаСервере
Процедура ПериодВыгрузкиПриИзмененииНаСервере()

	Уроки.Отбор.Элементы.Очистить();
	
	ЭлементОтбора = Уроки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Дата");
	ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно;
	ЭлементОтбора.ПравоеЗначение = ПериодВыгрузки.ДатаНачала;
	ЭлементОтбора = Уроки.Отбор.Элементы[0];
	ЭлементОтбора.Использование = Истина;
	
	ЭлементОтбора2 = Уроки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбора2.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Дата");
	ЭлементОтбора2.ВидСравнения = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно;
	ЭлементОтбора2.ПравоеЗначение = ПериодВыгрузки.ДатаОкончания;
	ЭлементОтбора2 = Уроки.Отбор.Элементы[1];
	ЭлементОтбора2.Использование = Истина;

	Элементы.Уроки.Обновить();		
	
КонецПроцедуры

&НаКлиенте
Процедура ПериодВыгрузкиПриИзменении(Элемент)
	ПериодВыгрузкиПриИзмененииНаСервере();
КонецПроцедуры
